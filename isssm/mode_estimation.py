# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/30_mode_estimation.ipynb.

# %% auto 0
__all__ = ['vmm', 'vdiag', 'mode_estimation']

# %% ../nbs/30_mode_estimation.ipynb 6
from .kalman import predict
from jaxtyping import Array, Float
from jax import grad, vmap, jacfwd, jacrev
from functools import partial
import jax.numpy as jnp
import jax.random as jrn

from .lcssm import nb_lcssm, simulate_lcssm, v_time
from jax.lax import scan
from .kalman import smoother, kalman
from .lcssm import v_time
from jax import grad, jacfwd, jacrev, jit

vmm = jit(vmap(jnp.matmul))
vdiag = jit(vmap(jnp.diag))

def mode_estimation(y, x0, A, Sigma, B, xi_fun, dist, s_init, n_iter):

    np1, _ = y.shape
    n = np1 - 1

    def log_lik(t, s):
        params = xi_fun(t, s)
        return dist(params).log_prob(y[t]).sum()

    d_log_lik = jacfwd(log_lik, argnums=1)
    dd_log_lik = jacrev(d_log_lik, argnums=1)

    vd_log_lik = v_time(d_log_lik)
    vdd_log_lik = v_time(dd_log_lik)


    vB = jit(partial(vmm, B))

    def iteration(carry, input):
        signal, = carry

        grad = vd_log_lik(jnp.arange(n + 1), signal)
        Gamma = -vdd_log_lik(jnp.arange(n + 1), signal)
        # assume hessian is diagonal
        Omega = vdiag(1. / vdiag(Gamma))

        z = signal + vmm(Omega, grad)
        x_filt, Xi_filt, x_pred, Xi_pred = kalman(
            z, x0, Sigma, Omega, A, B
        )

        x_smooth, Xi_smooth = smoother(x_filt, Xi_filt, x_pred, Xi_pred, A)

        signal = vB(x_smooth)

        return (signal,), (x_smooth, z, Gamma)

    _, (x_smooth, z, Gamma) = scan(iteration, (s_init,), (jnp.arange(n_iter),))

    return (x_smooth[-1], z[-1], Gamma[-1])
