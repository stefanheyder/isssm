# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/30_mode_estimation.ipynb.

# %% auto 0
__all__ = ['vmm', 'vdiag', 'vvmap', 'SmoothState', 'PseudoObs', 'PseudoObsCov', 'mode_estimation']

# %% ../nbs/30_mode_estimation.ipynb 7
from .kalman import predict
from jaxtyping import Array, Float
from jax import grad, vmap, jacfwd, jacrev
from functools import partial
import jax.numpy as jnp
import jax.random as jrn

from .typing import InitialState

from .lcssm import nb_lcssm, simulate_lcssm
from jax.lax import scan
from .kalman import smoother, kalman
from jax import jacfwd, jacrev, jit

vmm = jit(vmap(jnp.matmul))
vdiag = jit(vmap(jnp.diag))
vvmap = lambda fun: vmap(vmap(fun))

SmoothState = Float[Array, "n+1 m"]
PseudoObs = Float[Array, "n+1 p"]
PseudoObsCov = Float[Array, "n+1 p p"]

def mode_estimation(
    y: Float[Array, "n+1 p"], # observation
    x0: InitialState, # initial state mean
    A: Float[Array, "n m m"], # state transition matrices
    Sigma: Float[Array, "n+1 m m"], # state covariance matrices
    B: Float[Array, "n+1 p m"], # observation matrices
    dist, # distribution of observations
    xi: Float[Array, "n+1 p"], # observation parameters
    s_init: Float[Array, "n+1 p"], # initial signal
    n_iter: int, # number of iterations
    log_lik=None, # log likelihood function
    d_log_lik=None, # derivative of log likelihood function
    dd_log_lik=None, # second derivative of log likelihood function
) -> tuple[SmoothState, PseudoObs, PseudoObsCov]:
    def default_log_lik(s_ti, xi_ti, y_ti):
        return dist(s_ti, xi_ti).log_prob(y_ti).sum()

    if log_lik is None:
        log_lik = default_log_lik

    if d_log_lik is None:
        d_log_lik = jacfwd(log_lik, argnums=0)
    if dd_log_lik is None:
        dd_log_lik = jacrev(d_log_lik, argnums=0)

    vd_log_lik = jit(vvmap(d_log_lik))
    vdd_log_lik = jit(vvmap(dd_log_lik))

    def iteration(carry, input):
        s, = carry

        grad = vd_log_lik(s, xi, y)
        Gamma = -vdd_log_lik(s, xi, y)
        # assume hessian is diagonal
        Omega = vdiag(1.0 / Gamma)

        z = s + grad / Gamma
        x_filt, Xi_filt, x_pred, Xi_pred = kalman(z, x0, Sigma, Omega, A, B)

        x_smooth, Xi_smooth = smoother(x_filt, Xi_filt, x_pred, Xi_pred, A)

        #s_new = vB(x_smooth)
        s_new = (B @ x_smooth[:,:, None])[:, :, 0]

        return (s_new,), (x_smooth, z, Omega)

    _, (x_smooth, z, Omega) = scan(iteration, (s_init,), (jnp.arange(n_iter),))

    return (x_smooth[-1], z[-1], Omega[-1])
