# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/Models/10_stsm.ipynb.

# %% auto 0
__all__ = ['stsm', 'add_seasonal']

# %% ../../nbs/Models/10_stsm.ipynb 1
import jax
import jax.numpy as jnp
from jaxtyping import Float, Array
from ..typing import GLSSM
import jax.scipy as jsp

# %% ../../nbs/Models/10_stsm.ipynb 5
def stsm(
    x0: Float[Array, "m"], # initial state
    s2_mu: Float, # variance of trend innovations
    s2_nu: Float, # variance of velocity innovations
    s2_seasonal: Float, # variance of velocity innovations
    n: int, # number of time points
    Sigma_init: Float[Array, "m m"], # initial state covariance
    o2: Float, # variance of observation noise
    s_order: int, # order of seasonal component
    alpha_velocity: Float = 1., # dampening factor for velocity
) -> GLSSM:

    A = jnp.array([[1, 1], [0, alpha_velocity]])
    B = jnp.array([[1, 0]])

    Sigma = jnp.diag(jnp.array([s2_mu, s2_nu]))


    if s_order >= 2:
        A_seasonal = jnp.block([
            [-jnp.ones((1,s_order - 1)), -jnp.ones((1,1))],
            [jnp.eye(s_order - 1), jnp.zeros((s_order - 1,1))]
        ])
        B_seasonal = (jnp.eye(s_order)[0])[None,:]
        Sigma_seasonal = jnp.diag(jnp.eye(s_order)[0] * s2_seasonal)

        A = jsp.linalg.block_diag(A, A_seasonal)
        B = jnp.concatenate((B, B_seasonal), axis=1)
        Sigma = jsp.linalg.block_diag(Sigma, Sigma_seasonal)
        
    
    A = jnp.broadcast_to(A, (n, s_order + 2, s_order + 2))
    B = jnp.broadcast_to(B, (n+1, 1, s_order + 2))
    Sigma = jnp.broadcast_to(Sigma, (n, s_order + 2, s_order + 2))
    Sigma = jnp.concatenate((Sigma_init[None, :, :], Sigma), axis=0)

    Omega = jnp.broadcast_to(jnp.diag(jnp.array([o2])), (n + 1, 1, 1))

    return GLSSM(x0, A, Sigma, B, Omega)

# %% ../../nbs/Models/10_stsm.ipynb 8
from jax import vmap

def add_seasonal(
    model: GLSSM,
    x0_seasonal: Float[Array, "m"], # initial state
    s2_seasonal: Float, # variance of sesaonal innovations
    Sigma_init_seasonal: Float[Array, "m m"], # initial state covariance
    s_order: int, # order of seasonal component
) -> GLSSM:

    x0, A, Sigma, B, Omega = model
    np1, p, m = B.shape
    n = np1 - 1

    if s_order >= 2:
        A_seasonal = jnp.block([
            [-jnp.ones((1,s_order - 1)), -jnp.ones((1,1))],
            [jnp.eye(s_order - 1), jnp.zeros((s_order - 1,1))]
        ])
        B_seasonal = jnp.broadcast_to(jnp.eye(s_order)[0], (p, s_order))

        Sigma_seasonal = jnp.diag(jnp.eye(s_order)[0] * s2_seasonal)
        Sigma_seasonal = jnp.broadcast_to(Sigma_seasonal, (n, s_order, s_order))
        Sigma_seasonal = jnp.concatenate((Sigma_init_seasonal[None], Sigma_seasonal), axis=0)

        x0 = jnp.concatenate((x0, x0_seasonal), axis=0)
        A = vmap(jsp.linalg.block_diag, (0, None))(A, A_seasonal)
        B = vmap(lambda M : jnp.concatenate((M, B_seasonal), axis = 1))(B)
        Sigma = vmap(jsp.linalg.block_diag)(Sigma, Sigma_seasonal)
        
    return GLSSM(x0, A, Sigma, B, Omega)
