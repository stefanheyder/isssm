# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/20_lcssm.ipynb.

# %% auto 0
__all__ = ['simulate_lcssm', 'nb_lcssm']

# %% ../nbs/20_lcssm.ipynb 5
from jaxtyping import Float, Array

# %% ../nbs/20_lcssm.ipynb 6
from isssm.glssm import simulate_states
from jax import vmap
import jax.numpy as jnp
import jax.random as jrn

# matmul with $(A_t)_{t}$ and $(X_t)_{t}$
mm_time = vmap(jnp.matmul, (0, 0))
# matmul with $(A_t)_{t}$ and $(X^i_t)_{i,t}$
mm_time_sim = vmap(mm_time, (None, 0))
def v_time(xi_fun):
    """Vectorized xi function over time only

    Parameters
    ----------
    xi_fun : 
        the function to be vectorized

    Returns
    -------
    vxi_fun:
        vectorzied version of xi_fun
    """
    return vmap(xi_fun, (0,0))

def v_sample(xi_fun):
    """Vectorized xi function over samples only

    Parameters
    ----------
    xi_fun : 
        the function to be vectorized

    Returns
    -------
    vxi_fun:
        vectorzied version of xi_fun
    """
    return vmap(xi_fun, (None, 0))


# %% ../nbs/20_lcssm.ipynb 7
def simulate_lcssm(
    x0: Float[Array, "m"],  # initial state
    A: Float[Array, "n m m"],  # transition matrices
    Sigma: Float[Array, "n+1 m m"],  # innovation covariances
    B: Float[Array, "n+1 p m"],  # signal matrices
    xi_fun,  # parameter function
    dist,  # observation distribution
    N: int,  # number of samples
    key: jrn.PRNGKeyArray,  # random key
) -> tuple[
    Float[Array, "N n+1 m"], Float[Array, "N n+1 p"]
]:  # simulated states and observations
    key, subkey = jrn.split(key)
    X = simulate_states(x0, A, Sigma, N, subkey)
    S = mm_time_sim(B, X)

    n, m, _ = A.shape

    vxi = v_sample(v_time(xi_fun))
    params = vxi(jnp.arange(n + 1), S)
    key, subkey = jrn.split(key)
    Y = dist(params).sample(seed=subkey)

    return X, Y

# %% ../nbs/20_lcssm.ipynb 9
from tensorflow_probability.substrates.jax.distributions import (
    NegativeBinomial as NBinom,
)


def nb_lcssm(
    x0: Float[Array, "m"], # initial state
    A: Float[Array, "n m m"], # transition matrices
    Sigma: Float[Array, "n+1 m m"], # innovation covariances
    B: Float[Array, "n+1 p m"], # signal matrices
    r: Float, # overdispersion parameter
): # negative binomial LCSSM
    """Create a negative binomial LCSSM with constant overdispersion"""
    r = jnp.atleast_1d(r)

    def xi_fun_nb(t, S):
        # does not depend on $t$
        return (r, S)

    def dist_nb(params):
        r, log_mu = params
        mu = jnp.exp(log_mu)
        return NBinom(r, probs=mu / (r + mu))

    return x0, A, Sigma, B, xi_fun_nb, dist_nb
