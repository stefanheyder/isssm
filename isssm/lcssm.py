# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/20_lcssm.ipynb.

# %% auto 0
__all__ = ['mm_time', 'mm_time_sim', 'simulate_pgssm', 'nb_pgssm_runnning_example', 'log_probs_y', 'log_prob']

# %% ../nbs/20_lcssm.ipynb 5
import jax.numpy as jnp
import jax.random as jrn
from jax import lax, vmap
from jaxtyping import Array, Float, PRNGKeyArray
from tensorflow_probability.substrates.jax.distributions import \
    NegativeBinomial as NBinom
from tensorflow_probability.substrates.jax.distributions import Poisson

from .glssm import log_probs_x, simulate_states
from .typing import PGSSM, GLSSMObservationModel, GLSSMState

# %% ../nbs/20_lcssm.ipynb 6
# matmul with $(A_t)_{t}$ and $(X_t)_{t}$
mm_time = vmap(jnp.matmul, (0, 0))
# matmul with $(A_t)_{t}$ and $(X^i_t)_{i,t}$
mm_time_sim = vmap(mm_time, (None, 0))

# %% ../nbs/20_lcssm.ipynb 7
def simulate_pgssm(
    pgssm: PGSSM,
    N: int,  # number of samples
    key: PRNGKeyArray,  # random key
) -> tuple[
    Float[Array, "N n+1 m"], Float[Array, "N n+1 p"]
]:  # simulated states and observations
    x0, A, Sigma, B, dist, xi = pgssm
    key, subkey = jrn.split(key)
    X = simulate_states(GLSSMState(x0, A, Sigma), N, subkey)
    S = mm_time_sim(B, X)

    Y = dist(S, xi).sample(seed=subkey)

    return X, Y

# %% ../nbs/20_lcssm.ipynb 9
from .models.glssm import mv_ar1
from .models.stsm import add_seasonal
from .models.pgssm import nb_pgssm

def nb_pgssm_runnning_example(
    x0_trend: Float[Array, "m"]=jnp.zeros(2),
    r: Float =20,
    Tau: Float[Array, "m m"]=.5 * jnp.array([[1., .5], [.5, 1.]]),
    alpha: Float =.5,
    omega2: Float=.01,
    n:int = 100,
    x0_seasonal: Float[Array, "s"]=jnp.zeros(5),
    s2_seasonal: Float = .1, 
    Sigma0_seasonal:Float[Array, "s s"] = jnp.eye(5),
    s_order:int = 5
) -> PGSSM:
    model = nb_pgssm(
        add_seasonal(
            mv_ar1(x0_trend, Tau, alpha, omega2, n),
            x0_seasonal, s2_seasonal, Sigma0_seasonal, s_order
        ),
        r
    )

    return model

# %% ../nbs/20_lcssm.ipynb 14
def log_probs_y(
    x: Float[Array, "n+1 m"],  # states
    y: Float[Array, "n+1 p"],  # observations
    B: Float[Array, "n+1 p m"],  # signal matrices
    dist,  # observation distribution
    xi, # observation parameters
):
    s = (B @ x[:,:,None])[:,:,0]
    return dist(s, xi).log_prob(y).sum(axis=1)

def log_prob(
    x: Float[Array, "n+1 m"],  # states
    y: Float[Array, "n+1 p"],  # observations
    model: PGSSM
):
    x0, A, Sigma, B, dist, xi = model
    px = log_probs_x(x, GLSSMState(x0, A, Sigma)).sum()
    py = log_probs_y(x, y, B, dist, xi).sum()
    return px + py
