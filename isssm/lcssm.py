# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/20_lcssm.ipynb.

# %% auto 0
__all__ = ['mm_time', 'mm_time_sim', 'simulate_lcssm', 'nb_lcssm', 'poisson_lcssm', 'log_probs_y', 'log_prob']

# %% ../nbs/20_lcssm.ipynb 5
import jax.numpy as jnp
import jax.random as jrn
from jax import lax, vmap
from jaxtyping import Array, Float, PRNGKeyArray
from tensorflow_probability.substrates.jax.distributions import \
    NegativeBinomial as NBinom
from tensorflow_probability.substrates.jax.distributions import Poisson

from .glssm import log_probs_x, simulate_states
from .typing import PGSSM, GLSSMObservationModel, GLSSMState

# %% ../nbs/20_lcssm.ipynb 6
# matmul with $(A_t)_{t}$ and $(X_t)_{t}$
mm_time = vmap(jnp.matmul, (0, 0))
# matmul with $(A_t)_{t}$ and $(X^i_t)_{i,t}$
mm_time_sim = vmap(mm_time, (None, 0))

# %% ../nbs/20_lcssm.ipynb 7
def simulate_lcssm(
    pgssm: PGSSM,
    N: int,  # number of samples
    key: PRNGKeyArray,  # random key
) -> tuple[
    Float[Array, "N n+1 m"], Float[Array, "N n+1 p"]
]:  # simulated states and observations
    x0, A, Sigma, B, dist, xi = pgssm
    key, subkey = jrn.split(key)
    X = simulate_states(GLSSMState(x0, A, Sigma), N, subkey)
    S = mm_time_sim(B, X)

    Y = dist(S, xi).sample(seed=subkey)

    return X, Y

# %% ../nbs/20_lcssm.ipynb 9
def nb_lcssm(
    x0: Float[Array, "m"], # initial state
    A: Float[Array, "n m m"], # transition matrices
    Sigma: Float[Array, "n+1 m m"], # innovation covariances
    B: Float[Array, "n+1 p m"], # signal matrices
    r: Float, # overdispersion parameter
) -> PGSSM: # negative binomial LCSSM
    """Create a negative binomial LCSSM with constant overdispersion"""

    np1,m, _ = B.shape
    xi = jnp.full((np1, m), r)

    def dist_nb(log_mu, xi):
        mu = jnp.exp(log_mu)
        return NBinom(r, probs=mu / (xi + mu))

    return PGSSM(x0, A, Sigma, B, dist_nb, xi)

# %% ../nbs/20_lcssm.ipynb 10
def poisson_lcssm(
    x0: Float[Array, "m"], # initial state
    A: Float[Array, "n m m"], # transition matrices
    Sigma: Float[Array, "n+1 m m"], # innovation covariances
    B: Float[Array, "n+1 p m"], # signal matrices
) -> PGSSM: # Poisson LCSSM
    """Create a negative binomial LCSSM with constant overdispersion"""

    np1,m, _ = B.shape

    def dist_pois(log_mu, xi):
        return Poisson(log_rate=log_mu)

    return PGSSM(x0, A, Sigma, B, dist_pois, jnp.empty((np1, m)))

# %% ../nbs/20_lcssm.ipynb 16
def log_probs_y(
    x: Float[Array, "n+1 m"],  # states
    y: Float[Array, "n+1 p"],  # observations
    B: Float[Array, "n+1 p m"],  # signal matrices
    dist,  # observation distribution
    xi, # observation parameters
):
    s = (B @ x[:,:,None])[:,:,0]
    return dist(s, xi).log_prob(y).sum(axis=1)

def log_prob(
    x: Float[Array, "n+1 m"],  # states
    y: Float[Array, "n+1 p"],  # observations
    model: PGSSM
):
    x0, A, Sigma, B, dist, xi = model
    px = log_probs_x(x, GLSSMState(x0, A, Sigma)).sum()
    py = log_probs_y(x, y, B, dist, xi).sum()
    return px + py
