# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/20_lcssm.ipynb.

# %% auto 0
__all__ = ['mm_time', 'mm_time_sim', 'v_time', 'v_sample', 'simulate_lcssm', 'nb_lcssm']

# %% ../nbs/20_lcssm.ipynb 3
from .glssm import simulate_states
from jax import vmap
import jax.numpy as jnp
import jax.random as jrn

# matmul with $(A_t)_{t}$ and $(X_t)_{t}$
mm_time = vmap(jnp.matmul, (0, 0))
# matmul with $(A_t)_{t}$ and $(X^i_t)_{i,t}$
mm_time_sim = vmap(mm_time, (None, 0))
def v_time(xi_fun):
    """Vectorized xi function over time only

    Parameters
    ----------
    xi_fun : 
        the function to be vectorized

    Returns
    -------
    vxi_fun:
        vectorzied version of xi_fun
    """
    return vmap(xi_fun, (0,0))

def v_sample(xi_fun):
    """Vectorized xi function over samples only

    Parameters
    ----------
    xi_fun : 
        the function to be vectorized

    Returns
    -------
    vxi_fun:
        vectorzied version of xi_fun
    """
    return vmap(xi_fun, (None, 0))

def simulate_lcssm(x0, A, Sigma, B, xi_fun, dist, N, key):
    key, subkey = jrn.split(key)
    X = simulate_states(x0, A, Sigma, N, subkey)
    S = mm_time_sim(B, X)
    
    n, m, _ = A.shape

    vxi = v_sample(v_time(xi_fun))
    params = vxi(jnp.arange(n + 1), S)
    key, subkey = jrn.split(key)
    Y = dist(params).sample(seed=subkey)

    return X, Y

# %% ../nbs/20_lcssm.ipynb 5
from tensorflow_probability.substrates.jax.distributions import NegativeBinomial as NBinom
def nb_lcssm(x0, A, Sigma, B, r):
    """Create a negative binomial common factor model

    Parameters
    ----------
    x0 : 
        initial state mean
    A : 
        state transition matrices
    Sigma : 
        innvovation covariances
    B : 
        signal matrix
    r :
        overdisperion parameter

    Returns
    -------
    lcssm:
        a negative binomial common factor model
    """
    r = jnp.atleast_1d(r)
    def xi_fun_nb(t, S):
        return (r, S)
    def dist_nb(params):
        r, log_mu = params
        mu = jnp.exp(log_mu)
        return NBinom(r, probs=mu/(r + mu))
        
    return x0, A, Sigma, B, xi_fun_nb, dist_nb
